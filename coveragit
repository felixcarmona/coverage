#!/usr/bin/env python
from xml.dom import minidom
from os import popen, getcwd, path
import re
import sys
import argparse
from itertools import groupby
from operator import itemgetter



class CoverageProcessorException(Exception):
        pass


class AdditionsFinder(object):
    @staticmethod
    def get_additions_for_base(base):
        additions = {}

        raw_diff = popen("git diff %s --unified=0" % base).read().strip()
        raw_diff_files = re.split('\ndiff', raw_diff)
        raw_diff_files = filter(None, raw_diff_files)  # remove empty elements from list

        for raw_diff_file in raw_diff_files:
            file_name = re.findall(r'\nindex .*\n.*\n\+\+\+ b/(.*)\n', raw_diff_file, re.MULTILINE)[0]
            additions[file_name] = []
            chunks = re.findall(r'^@@ .* \+(.*[^,0]) @@', raw_diff_file, re.MULTILINE)
            for chunk in reversed(chunks):
                lines_range = chunk.split(',')
                if len(lines_range) == 2:
                    additions[file_name] += range(int(lines_range[0]), int(lines_range[0]) + int(lines_range[1]))
                else:
                    additions[file_name].append(int(lines_range[0]))

        return additions


class CoverageProcessor(object):
    def __init__(self):
        pass

    @staticmethod
    def _get_uncovered_code(xml_path):
        if not path.isfile(xml_path):
            raise CoverageProcessorException("No such coverage .xml file '%s'" % xml_path)

        try:
            xml_doc = minidom.parse(xml_path)

            files_dom = xml_doc.getElementsByTagName('file')

            uncovered_code = {}
            i = 1
            for file_dom in files_dom:
                progress = 100 * float(i)/float(len(files_dom))
                progress = int(progress)
                sys.stdout.write('\r\033[36mProcessing coverage... [{0}{1}] {2}%\033[m'.format('#'*(progress/10), ' '*(10-progress/10), progress))
                sys.stdout.flush()
                uncovered_lines = []

                lines_dom = xml_doc.getElementsByTagName('line')
                for line_dom in lines_dom:
                    count = int(line_dom.attributes['count'].value)
                    line_number = int(line_dom.attributes['num'].value)
                    if count == 0:
                        uncovered_lines.append(line_number)

                if uncovered_lines:
                    cwd = getcwd().rstrip('/') + '/'
                    file_name = file_dom.attributes['name'].value
                    file_name = re.sub('^%s' % cwd, '', file_name)
                    uncovered_code[file_name] = uncovered_lines

                i += 1
            sys.stdout.write("\r")
            sys.stdout.flush()
            return uncovered_code
        except Exception:
            raise CoverageProcessorException("Invalid coverage .xml file '%s'" % xml_path)

    def get_missing_coverage(self, additions, xml_path):
        uncovered_code = self._get_uncovered_code(xml_path)

        missing_coverage = {}

        relevant_files = list(set(uncovered_code) & set(additions))

        for file_name in relevant_files:
            uncovered_lines = uncovered_code[file_name]
            relevant_lines = additions[file_name]
            uncovered_relevant_lines = list(set(uncovered_lines) & set(relevant_lines))
            missing_coverage[file_name] = uncovered_relevant_lines

        return missing_coverage

class ConsoleDisplay(object):
    @staticmethod
    def _add_graceful_extra_lines(lines):
        for line in lines:
            if line+1 not in lines and line+2 in lines:
                lines.append(line+1)

        return lines

    @staticmethod
    def _split_chunks(lines):
        lines = sorted(lines)
        result = []
        for k, g in groupby(enumerate(lines), lambda ix : ix[0] - ix[1]):
            result.append(map(itemgetter(1), g))

        return result

    def _add_extra_lines(self, line_numbers, file_lines_size):
        result = []
        for line_number in line_numbers:
            if line_number-1 not in result:
                result.append(line_number-1)

            if line_number not in result:
                result.append(line_number)

            if line_number+1 not in result:
                result.append(line_number+1)

        result = [line_number for line_number in result if 1 <= line_number <= file_lines_size]

        result = self._add_graceful_extra_lines(result)

        return result

    def display_missing_coverage(self, missing_coverage, is_concise):
        for file_name in missing_coverage:
            print("\033[41m\033[37m %s \033[m" % file_name)

            file_lines = [''] + [file_line.rstrip() for file_line in open(file_name)]  # [''] + because lists are zero-based

            uncovered_lines = missing_coverage[file_name]
            displayable_lines = self._add_extra_lines(uncovered_lines, len(file_lines)-1)
            last_line = max(displayable_lines)
            chunks = self._split_chunks(displayable_lines)

            i = 1
            for chunk in chunks:
                for line in chunk:
                    line_zerofill = str(line).zfill(len("%s" % last_line))
                    if line in uncovered_lines:
                        print("%s: \033[31m%s\033[m" % (line_zerofill, file_lines[line]))
                    elif not is_concise:
                        print("%s: %s" % (line_zerofill, file_lines[line]))
                if not is_concise and i < len(chunks):
                    print("\033[36m-----------------------------------------\033[m")
                i += 1

            print("")


class ConsoleApplication:
    def __init__(self):
        parser = argparse.ArgumentParser(description='Check the uncovered code lines which have been modified or added in an specific pull request or commit')
        parser.add_argument('--base', '-b', type=str, default='HEAD~1', help='Base branch, tag, commit, or history marker to compare the current revision')
        parser.add_argument('--concise', '-c', action='store_true', help='Only display the affected uncovered lines')
        parser.add_argument('--xml', '-x', type=str, default='coverage.xml', help='Path of the generated coverage .xml')
        parser.add_argument('--silently', '-s', action='store_true', help='Even with missing coverage, exit with success system exit status')
        parser.set_defaults(concise=False)

        args = parser.parse_args()

        self._additions_finder = AdditionsFinder()
        self._coverage_processor = CoverageProcessor()
        self._base = args.base
        self._xml = args.xml
        self._concise = args.concise
        self._silently = args.silently

    def run(self):
        try:
            additions = self._additions_finder.get_additions_for_base(self._base)
            missing_coverage = self._coverage_processor.get_missing_coverage(additions, self._xml)

            if missing_coverage:
                visualizer = ConsoleDisplay()
                visualizer.display_missing_coverage(missing_coverage, self._concise)
                if not self._silently:
                    sys.exit(2)
            else:
                print('\033[32m100% relevant lines covered\033[m')
        except Exception as e:
            print("\033[31m %s\033[m" % e.message)
            sys.exit(2)


ConsoleApplication().run()